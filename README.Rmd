---
title: "jti: Junction Tree Inference"
output:
  github_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warnings = FALSE,
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

<!-- badges: start -->
[![R buildstatus](https://github.com/mlindsk/jti/workflows/R-CMD-check/badge.svg)](https://github.com/mlindsk/jti/actions)
<!-- badges: end -->

## About

The **jti** package (pronounced 'yeti') is a fast implementaion of the junction tree algorithm (JTA) using the Lauritzen-Spiegelhalter scheme. Why is it fast? Because we use a sparse representation for the potentials which enable us to handle large and complex graphs where the variables can have an arbitrary large number of levels.

## Installation

You can install the current stable release of the package by using the `devtools` package: 

```{r, eval = FALSE}
devtools::install_github("mlindsk/jti", build_vignettes = FALSE)
```
## Libraries

```{r}
library(jti)
library(igraph)
```

## Setting up the network

```{r}
el <- matrix(c(
  "A", "T",
  "T", "E",
  "S", "L",
  "S", "B",
  "L", "E",
  "E", "X",
  "E", "D",
  "B", "D"),
  nc = 2,
  byrow = TRUE
)

g <- igraph::graph_from_edgelist(el)
plot(g)
```

## Compilation

After the network has been compiled, the graph has been triangulated and moralized. Furthermore, all conditional probability tables (CPTs) has been designated one of the cliques (in the triangulated and moralized graph).

```{r}
cp <- compile(asia, g)
```

## Example 1: sum-flow without evidence

```{r}
jt1 <- jt(cp)
plot(jt1)
print(jt1)
query_belief(jt1, c("E", "L", "T"))
query_belief(jt1, c("B", "D", "E"), type = "joint")
```


## Example 2: sum-flow with evidence

```{r}
e2  <- c(A = "y", X = "n")
jt2 <- jt(cp, e2) 
query_belief(jt2, c("E", "L", "T"))
query_belief(jt2, c("B", "D", "E"), type = "joint")
```

Notice that, the configuration `(D,E,B) = (y,y,n)` has changed dramatically as a consequence of the evidence. We can get the probability of the evidence:

```{r}
query_evidence(jt2)
```

## Example 3: max-flow without evidence

```{r}
jt3 <- jt(cp, flow = "max")
mpe(jt3)
```

##  Example 4: max-flow with evidence

```{r}
e4  <- c(T = "y", X = "y", D = "y")
jt4 <- jt(cp, e4, flow = "max")
mpe(jt4)

```
Notice, that `S, B` and `E` has changed from `"n"` to `"y"` as a consequence of the new evidence `e4`.

##  Example 5: specifying a root node and only collect to save run time

```{r}
cp5 <- compile(asia, g, "X")
jt5 <- jt(cp5, propagate = "collect")
```
We can only query from the root clique now (clique 1) but we have ensured that the node of interest, `"X"`, does indeed live in this clique.

```{r}
query_belief(jt5, get_cliques(jt5)$C1, "joint")
```

##  Example 6: Compiling from a list of conditional probabilities

1) We need a list with CPTs which we extract from the asia2 object
    - the list must be named with child nodes
 2) The elements need to by an array-like object
 3) The list of cpts needs to be converted into a `cpt_list` object
    - This is merely for checking if the cpts are of the correct type,
    - but also the cpts are now converted to a sparse representation
      to obtain a better runtime in the compilation and propagation phase

```{r}
cl  <- cpt_list(asia2)
cp6 <- compile(cl)
```
Finally, `cp6` is now of the same form as cp above and we can use the junction tree algorithm

```{r}
jt6 <- jt(cp6)
query_belief(jt6, c("either", "smoke"))
query_belief(jt6, c("either", "smoke"), type = "joint")
```

##  Example 7: Fitting a decomposable model and apply JTA

We use the `ess` package (on CRAN), found at https://github.com/mlindsk/ess, to fit an undirected decomposable graph to data.

```{r}
library(ess)

g7  <- ess::fit_graph(asia, trace = FALSE)
ig7 <- igraph::graph_from_adjacency_matrix(ess::adj_mat(g7), "undirected")
cp7 <- compile(asia, ig7)
jt7 <- jt(cp7)

query_belief(jt7, get_cliques(jt7)$C4, type = "joint")
```
